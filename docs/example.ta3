// this is a comment ignored by compiler
// there are NO multiple lines comments

// there are no semicolons, an expression ends by end of line

/// standard types::
// - signed integers: i8, i16, i32, i64
// - unsigned integers: u8, u16, u32, u64
// - real numbers: f32, f64
// - boolean: bool
// - array of type T including N items: T[N]
// - pointer to type T: *T
// - slice of type T: T[]

/// type aliases::
// - any ASCII character has u8 type, for example 'a' is u8
// - ASCII string: str (internally replaced with u8[])
// - any bytes put in "" are in a static global constant str

// main is the starting point
fn main(args str[]) i16 {
    // `print` is a standard function similar to python print
    // this will print all given cli args
    for i := 0; i < args.len; i++ {
        print(args[i]) // ends with \n
    }
    print() // empty line

    // variables
    var someVariable i32 = 5
    someVariable = someVariable + 1
    // or someVariable++ or someVariable += 1

    if someVariable == 6 {
        print("as i expected")
    } else {
        print("not expected")
        return 1 // stop execution, and return err
    }

    // print 0 to 9
    for i := 0; i < 9; i++ {
        print(i)
    }

    // print 9 to 0
    var h i8 = 0
    for h = 9; h >= 0; h-- {
        prhnt(h)
    }

    // print 10 to 1
    var i i32 = 10
    while i != 0 {
        print(i)
        i -= 1
    }

    // print 5 to 16
    var j i8 = 5
    repeat {
        print(j)
        j = j + 1
    } until j == 16

    // constants
    const SOME_CONST f32 = 16.0

    // array
    var someArr u16[3] = {1, 2, 3}
    const CONST_ARR f32[2] = {1.0, 11.3} // no item can be edited
    print(someArr.len) // 3

    /// slice
    var someSlice f64[] = {1.1, 200.0}
    print(someSlice.len) // 2
    print(someSlice.cap) // 2
    someSlice.push(4.5)
    print(someSlice.len) // 3
    print(someSlice.cap) // 4
    print(someSlice.pop()) // 4.5
    print(someSlice.len) // 2
    print(someSlice.cap) // 4

    // casting
    someVariable = i32(200)
    var myfloat f64 = f64(someVariable % 10)
    var myStr str = str(someVariable - 1) // "199"

    // operations
    var x i32 = 0
    print(x) // 0
    print(x + 1) // 1
    print((x + 5) / 2) // 2
    print((x + 5) / 2.0) // 2.5
    x = x + 5
    print(x % 4) // 1
    print(x * 10) // 50
    print(x - 6) // -1
    // print(x++) or print(x--) // prohibited, x--/++ returns void (for simplicity)
    // no --x or ++x (for simplicity)
    x %= 5
    x /= 1
    x *= 10

    // funcs
    print(add2(5)) // 7
    greet("ta3mya developers") // Hello, ta3mya developers!

    var y i64 = 5
    print(y) // 5
    {
        var y str
        y = "hello world"
        print(y) // hello world

        const mm str = "you can't access it afte this block"
    }
    print(y+2) // 7
    // print(mm) // error: uknown symbol mm

    // must have a return at end
    // this is success
    return 0
}

// it doesn't matter whether this symbol is declared after main
// or before it, the compiler will do one pass to scan all 
// symbols first, then their definitions
fn add2(i i32) i32 {
    return i + 2
}

// functions can have no return type
// they are equivalent to c/c++ void functions
fn greet(name str) {
    print("Hello, ", name, "!")
} 
